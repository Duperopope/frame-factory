/**
 * FRAME Factory - Persistence System
 * Syst√®me de persistance pour l'IA et les donn√©es utilisateur
 */

class PersistenceManager {
    constructor() {
        this.storageKey = 'frameFactory_data';
        this.version = '0.1.5.0';
        this.data = this.loadData();
        this.autoSaveInterval = null;
        this.contributionWorker = null;
        
        // Initialiser l'auto-sauvegarde
        this.startAutoSave();
        
        // Initialiser la contribution passive
        this.startPassiveContribution();
    }

    /**
     * Charger les donn√©es depuis localStorage
     */
    loadData() {
        try {
            const stored = localStorage.getItem(this.storageKey);
            if (stored) {
                const data = JSON.parse(stored);
                
                // V√©rifier la version pour migration si n√©cessaire
                if (data.version !== this.version) {
                    return this.migrateData(data);
                }
                
                console.log('‚úÖ Donn√©es persistantes charg√©es:', data);
                return data;
            }
        } catch (error) {
            console.error('‚ùå Erreur lors du chargement des donn√©es:', error);
        }
        
        // Donn√©es par d√©faut
        return this.getDefaultData();
    }

    /**
     * Donn√©es par d√©faut
     */
    getDefaultData() {
        return {
            version: this.version,
            timestamp: Date.now(),
            user: {
                id: this.generateUserId(),
                contributionScore: 0,
                optimizationsRun: 0,
                buildsCreated: 0
            },
            ai: {
                learnedBuilds: [],
                optimizationHistory: [],
                userPreferences: {},
                performanceMetrics: {
                    averageOptimizationTime: 0,
                    successRate: 0,
                    totalCalculations: 0
                }
            },
            builds: {
                saved: [],
                favorites: [],
                shared: []
            },
            settings: {
                autoSave: true,
                contributePassively: true,
                maxStoredBuilds: 100,
                optimizationTimeout: 30000
            },
            cache: {
                warframeData: null,
                lastApiUpdate: 0,
                optimizationResults: {}
            }
        };
    }

    /**
     * Sauvegarder les donn√©es
     */
    saveData(data = null) {
        try {
            const dataToSave = data || this.data;
            dataToSave.timestamp = Date.now();
            
            localStorage.setItem(this.storageKey, JSON.stringify(dataToSave));
            console.log('üíæ Donn√©es sauvegard√©es:', dataToSave);
            
            // √âmettre un √©v√©nement pour notifier les autres composants
            window.dispatchEvent(new CustomEvent('dataSaved', { detail: dataToSave }));
            
            return true;
        } catch (error) {
            console.error('‚ùå Erreur lors de la sauvegarde:', error);
            return false;
        }
    }

    /**
     * D√©marrer l'auto-sauvegarde
     */
    startAutoSave() {
        if (this.data.settings.autoSave) {
            this.autoSaveInterval = setInterval(() => {
                this.saveData();
            }, 30000); // Sauvegarde toutes les 30 secondes
            
            console.log('üîÑ Auto-sauvegarde activ√©e (30s)');
        }
    }

    /**
     * Arr√™ter l'auto-sauvegarde
     */
    stopAutoSave() {
        if (this.autoSaveInterval) {
            clearInterval(this.autoSaveInterval);
            this.autoSaveInterval = null;
            console.log('‚èπÔ∏è Auto-sauvegarde arr√™t√©e');
        }
    }

    /**
     * D√©marrer la contribution passive
     */
    startPassiveContribution() {
        if (this.data.settings.contributePassively) {
            // Simuler un worker pour la contribution passive
            this.contributionWorker = setInterval(() => {
                this.processPassiveContribution();
            }, 60000); // Contribution toutes les minutes
            
            console.log('ü§ù Contribution passive activ√©e');
        }
    }

    /**
     * Traiter la contribution passive
     */
    processPassiveContribution() {
        // Simuler le calcul de builds en arri√®re-plan
        const contribution = {
            timestamp: Date.now(),
            buildsCalculated: Math.floor(Math.random() * 10) + 1,
            optimizationScore: Math.random() * 100
        };
        
        this.data.user.contributionScore += contribution.buildsCalculated;
        this.data.ai.performanceMetrics.totalCalculations += contribution.buildsCalculated;
        
        console.log('üîÑ Contribution passive:', contribution);
        
        // Sauvegarder automatiquement
        this.saveData();
    }

    /**
     * Ajouter un build optimis√© √† l'IA
     */
    addOptimizedBuild(build) {
        if (!build || !build.warframe || !build.weapons) {
            console.error('‚ùå Build invalide pour l\'IA');
            return false;
        }
        
        const aiEntry = {
            id: this.generateBuildId(),
            timestamp: Date.now(),
            build: build,
            score: build.score || 0,
            contentType: build.contentType || 'general',
            enemyLevel: build.enemyLevel || 150,
            faction: build.faction || 'mixed'
        };
        
        this.data.ai.learnedBuilds.push(aiEntry);
        this.data.user.buildsCreated++;
        
        // Limiter le nombre de builds stock√©s
        if (this.data.ai.learnedBuilds.length > this.data.settings.maxStoredBuilds) {
            this.data.ai.learnedBuilds.shift(); // Supprimer le plus ancien
        }
        
        console.log('üß† Build ajout√© √† l\'IA:', aiEntry);
        this.saveData();
        return true;
    }

    /**
     * Obtenir les builds similaires de l'IA
     */
    getSimilarBuilds(criteria) {
        const similar = this.data.ai.learnedBuilds.filter(entry => {
            return (
                (!criteria.contentType || entry.contentType === criteria.contentType) &&
                (!criteria.faction || entry.faction === criteria.faction) &&
                (!criteria.enemyLevel || Math.abs(entry.enemyLevel - criteria.enemyLevel) <= 50)
            );
        });
        
        // Trier par score d√©croissant
        return similar.sort((a, b) => b.score - a.score);
    }

    /**
     * Mettre √† jour les pr√©f√©rences utilisateur
     */
    updateUserPreferences(preferences) {
        this.data.ai.userPreferences = { ...this.data.ai.userPreferences, ...preferences };
        this.saveData();
        console.log('üë§ Pr√©f√©rences utilisateur mises √† jour:', preferences);
    }

    /**
     * Enregistrer une optimisation
     */
    recordOptimization(optimization) {
        this.data.ai.optimizationHistory.push({
            timestamp: Date.now(),
            duration: optimization.duration,
            combinationsTested: optimization.combinationsTested,
            bestScore: optimization.bestScore,
            success: optimization.success
        });
        
        this.data.user.optimizationsRun++;
        
        // Mettre √† jour les m√©triques de performance
        this.updatePerformanceMetrics();
        
        this.saveData();
        console.log('üìä Optimisation enregistr√©e:', optimization);
    }

    /**
     * Mettre √† jour les m√©triques de performance
     */
    updatePerformanceMetrics() {
        const history = this.data.ai.optimizationHistory;
        if (history.length === 0) return;
        
        const totalTime = history.reduce((sum, opt) => sum + opt.duration, 0);
        const successCount = history.filter(opt => opt.success).length;
        
        this.data.ai.performanceMetrics.averageOptimizationTime = totalTime / history.length;
        this.data.ai.performanceMetrics.successRate = (successCount / history.length) * 100;
    }

    /**
     * Exporter les donn√©es
     */
    exportData() {
        const exportData = {
            ...this.data,
            exportTimestamp: Date.now(),
            exportVersion: this.version
        };
        
        const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `frame-factory-data-${new Date().toISOString().slice(0, 10)}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        console.log('üì§ Donn√©es export√©es');
    }

    /**
     * Importer les donn√©es
     */
    importData(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const importedData = JSON.parse(e.target.result);
                    
                    // Valider les donn√©es import√©es
                    if (this.validateImportedData(importedData)) {
                        this.data = this.migrateData(importedData);
                        this.saveData();
                        console.log('üì• Donn√©es import√©es avec succ√®s');
                        resolve(this.data);
                    } else {
                        reject(new Error('Donn√©es import√©es invalides'));
                    }
                } catch (error) {
                    reject(error);
                }
            };
            reader.readAsText(file);
        });
    }

    /**
     * Valider les donn√©es import√©es
     */
    validateImportedData(data) {
        return (
            data &&
            typeof data === 'object' &&
            data.version &&
            data.user &&
            data.ai &&
            data.builds
        );
    }

    /**
     * Migrer les donn√©es d'une ancienne version
     */
    migrateData(oldData) {
        console.log(`üîÑ Migration des donn√©es de ${oldData.version} vers ${this.version}`);
        
        const newData = this.getDefaultData();
        
        // Pr√©server les donn√©es importantes
        if (oldData.user) {
            newData.user = { ...newData.user, ...oldData.user };
        }
        
        if (oldData.ai) {
            newData.ai = { ...newData.ai, ...oldData.ai };
        }
        
        if (oldData.builds) {
            newData.builds = { ...newData.builds, ...oldData.builds };
        }
        
        return newData;
    }

    /**
     * G√©n√©rer un ID utilisateur unique
     */
    generateUserId() {
        return 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    /**
     * G√©n√©rer un ID de build unique
     */
    generateBuildId() {
        return 'build_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    /**
     * Nettoyer les donn√©es (supprimer les anciennes entr√©es)
     */
    cleanup() {
        const now = Date.now();
        const maxAge = 30 * 24 * 60 * 60 * 1000; // 30 jours
        
        // Nettoyer l'historique d'optimisation
        this.data.ai.optimizationHistory = this.data.ai.optimizationHistory.filter(
            entry => now - entry.timestamp < maxAge
        );
        
        // Nettoyer le cache
        if (this.data.cache.lastApiUpdate && now - this.data.cache.lastApiUpdate > maxAge) {
            this.data.cache.warframeData = null;
            this.data.cache.lastApiUpdate = 0;
        }
        
        this.saveData();
        console.log('üßπ Nettoyage des donn√©es effectu√©');
    }

    /**
     * Obtenir les statistiques
     */
    getStats() {
        return {
            user: this.data.user,
            ai: {
                learnedBuildsCount: this.data.ai.learnedBuilds.length,
                optimizationHistoryCount: this.data.ai.optimizationHistory.length,
                performanceMetrics: this.data.ai.performanceMetrics
            },
            builds: {
                savedCount: this.data.builds.saved.length,
                favoritesCount: this.data.builds.favorites.length,
                sharedCount: this.data.builds.shared.length
            },
            storage: {
                dataSize: JSON.stringify(this.data).length,
                lastSave: this.data.timestamp
            }
        };
    }

    /**
     * R√©initialiser toutes les donn√©es
     */
    reset() {
        if (confirm('‚ö†Ô∏è √ätes-vous s√ªr de vouloir r√©initialiser toutes les donn√©es ? Cette action est irr√©versible.')) {
            localStorage.removeItem(this.storageKey);
            this.data = this.getDefaultData();
            this.saveData();
            console.log('üîÑ Donn√©es r√©initialis√©es');
            
            // Recharger la page
            window.location.reload();
        }
    }
}

// Instance globale
window.persistenceManager = new PersistenceManager();

// Sauvegarder avant de quitter la page
window.addEventListener('beforeunload', () => {
    if (window.persistenceManager) {
        window.persistenceManager.saveData();
    }
});

console.log('üíæ Syst√®me de persistance initialis√©');
